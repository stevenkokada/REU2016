(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["piab`"]*)
(**)
(**)
(*startInitialization::usage="startInitialization[numberBasisFunctions_, numberParticles_] takes in number of basis elements and number of particles to set variables to be used by other functions in piab"*)
(*createSinBasis::usage="createSinBasis[] generates a list of normalized sine basis functions with equal number of up and down orbitals"*)
(*createRandomIC::usage="createRandomIC[] generates random initial guess at coefficients of basis functions for normalized wavefunction"*)
(*createDensityMatrix::usage="createDensityMatrix[coefficients_] generates the probability density matrix associated with coefficients_ matrix"*)
(*simpleInnerProduct::usage="simpleInnerProduct[belement1_, belement2_] computes inner product between two basis spin orbitals defined in the box"*)
(*createOverlapMatrix::usage="createOverlapMatrix[basis_] generates the overlap matrix associated with basis_ vector"*)
(*createH1Element::usage="createH1Element[belement1_, belement2_] computes matrix element with belement1_ and belement2_ acting on the single particle Hamiltonian from left and right respectively"*)
(*createH1Matrix::usage="createH1Matrix[basis_] generates matrix representation of single particle Hamiltonian in given basis_ vector"*)
(*mullenInteraction::usage="mullenInteraction[belement1_, belement2_, belement3_, belement4_] computes, using hardcoded analytic formulas, harmonic interaction integral with belement1_ and belement2_, and belement3_ and belement4_ acting on the double particle Hamiltonian from left and right respectively"*)
(*(*taken from Professor Mullen's code*)*)
(*create4Interaction::usage="create4Interaction[belement1_, belement2_, belement3_, belement4_] is just a renaming of the above mullenInteraction function"*)
(*createH2SubElement::usage="createH2SubElement[belement1_, belement2_, belement3_, belement4_] computes full element of double particle tensor as coloumbic - exchange terms"*)
(*createH2Tensor::usage="createH2Tensor[basis_, \[Alpha]_] computes tensor consisting of interaction terms between basis elements that can be contracted with density matrix to get H2 interaction matrix; \[Alpha]_ is spring constant in harmonic interaction; most computationally expensive step"*)
(*createH2Matrix::usage="createH2Matrix[densitymat_, h2tensor_] computes matrix representation of double particle Hamiltonian in the given basis with the given density matrix densitymat_"*)
(*createFockMatrix::usage="createFockMatrix[basis_,coeff_,h2tensor_] computes matrix representation of Fock Hamiltonian given a precomputed h2tensor_ by computing and adding together the single and double particle Hamiltonians"*)
(*iterateFockMatrix::usage="iterateFockMatrix[h1matrix_,h2tensor_,previousfm_] selects numpar_ lowest energy eigenvectors of old Fock matrix and compute new coefficients and density matrix before generating the newly updated Fock matrix; can be called repeatedly until convergence"*)
(*create1PWaveFunction::usage="create1PWaveFunction[particleindex_,coeff_,basis_] reconstructs 1 particle wavefunction for particleindex_th particle using the final coefficients (from HF convergence) and given basis"*)
(*createSlaterDeterminant::usage="createSlaterDeterminant[list1PWaveFunction_] creates slater determinant of single particle wavefunctions"*)
(*simple1PInnerProduct::usage="simple1PInnerProduct[p1wf_,p2wf_] computes inner product between two single particle wavefunctions"*)
(*simplePermInnerProduct::usage="simplePermInnerProduct[npwf1_,npwf2_] computes inner product between two tensor products corresponding to permutations of single particle wave functions"*)
(*coordinatePermRepresentation::usage="coordinatePermRepresentation[perm_] expresses permutation in position/spin basis"*)
(*coordinateSDRepresentation::usage="coordinateSDRepresentation[sd_] expresses slater determinant in position/spin basis"*)
(**)
(**)
(**)
(**)
(**)
(**)
(**)
(*Begin["Private`"]*)
(**)
(**)
(*startInitialization[numberBasisFunctions_, numberParticles_,springconstant_]:=( *)
(*numbas=numberBasisFunctions;*)
(*numpar=numberParticles;*)
(*alpha = springconstant;*)
(**)
(**)
(*);*)
(**)
(**)
(*createSinBasis[]:=( *)
(*Return[Join[Table[{Sqrt[2]*Sin[n*\[Pi]*x],up}, {n,1,Floor[numbas/2]}],Table[{Sqrt[2]*Sin[n*\[Pi]*x],down}, {n,1,Floor[numbas/2]}]]]*)
(*);*)
(**)
(*createRandomIC[]:=( *)
(*Module[{guess={}},*)
(**)
(*guess=Table[RandomComplex[], {n,1,numpar},{m,1, numbas}];*)
(*guess=Normalize /@ guess;*)
(*Return[guess]*)
(*]*)
(*);*)
(**)
(*createDensityMatrix[coefficients_]:=( *)
(*Return[ConjugateTranspose[coefficients].coefficients]*)
(*);*)
(**)
(**)
(*simpleInnerProduct[belement1_,belement2_] := ( *)
(*Return[If[SameQ[belement1[[2]],belement2[[2]]],Integrate[Conjugate[belement1[[1]]]*belement2[[1]],{x,0,1},  Assumptions->x\[Element]Reals],0]]*)
(*);*)
(**)
(**)
(*createOverlapMatrix[basis_]:=( *)
(**)
(*Return[ParallelTable[simpleInnerProduct[basis[[n]],basis[[m]]],{n,1,numbas},{m,1,numbas}]]*)
(**)
(*);*)
(**)
(*createH1Element[belement1_,belement2_] :=( *)
(*Return[simpleInnerProduct[belement1,{-D[belement2[[1]],{x,2}],belement2[[2]]}]]*)
(**)
(*);*)
(**)
(*createH1Matrix[basis_]:=( *)
(**)
(*Return[ParallelTable[createH1Element[basis[[n]],basis[[m]]],{n,1,numbas},{m,1,numbas}]]*)
(**)
(*);*)
(**)
(*mullenInteraction[belement1_,belement2_,belement3_, belement4_]:=( *)
(**)
(*f[_[x__]]:=x;*)
(*Module[{int1,int2,int3,int4},*)
(**)
(*int1=f[belement1[[1]]/Sqrt[2]]/(\[Pi] x);*)
(*int2=f[belement2[[1]]/Sqrt[2]]/(\[Pi] x);*)
(*int3=f[belement3[[1]]/Sqrt[2]]/(\[Pi] x);*)
(*int4=f[belement4[[1]]/Sqrt[2]]/(\[Pi] x);*)
(**)
(*matFxn[m0_,n0_,p0_,q0_]:=( *)
(**)
(*temp2ref=-((4 m n (-2 (-1+E^(I (m+n) \[Pi])) p q+2 (-1)^(p+q) (-1+E^(I (m+n) \[Pi])) p q))/((m-n)^2 (m+n)^2 \[Pi]^4 (p-q)^2 (p+q)^2));*)
(*temp2aref=(12 n^2 p \[Pi] q (p^2-q^2)+12 (-1)^(p+q) n^2 p \[Pi] q (p^2-q^2))/(12 n^2 \[Pi]^3 (p-q)^3 (p+q)^3);*)
(*temp3=(m n ((-1)^(m+n)+(-1)^(1+m+n)+2 p^2 \[Pi]^2+2 (-1)^(m+n) p^2 \[Pi]^2))/(2 (m-n)^2 (m+n)^2 p^2 \[Pi]^4);*)
(*temp4=(-3 n^2 p \[Pi]+p \[Pi] (-6 p^2+n^2 (-3+2 p^2 \[Pi]^2)))/(48 n^2 p^3 \[Pi]^3);*)
(**)
(* (form=Which[m0==n0&&p0==q0, temp4, p0==q0 && m0!=n0, temp3, p0!=q0 && m0==n0, temp2aref, m0!= n0 && p0!=q0, temp2ref, True, Print["Error"]; Null];*)
(*form/. {m-> m0, n-> n0, p-> p0, q-> q0})*)
(*);*)
(**)
(*Return[matFxn[int1,int3,int2,int4]]*)
(*]*)
(*);*)
(**)
(*create4Interaction[belement1_,belement2_,belement3_,belement4_]:=( *)
(*Return[mullenInteraction[belement1,belement2,belement3,belement4]]*)
(**)
(*);*)
(**)
(*createH2SubElement[belement1_,belement2_,belement3_,belement4_]:=( *)
(*Return[create4Interaction[belement1, belement2,belement3,belement4]-create4Interaction[belement1, belement2,belement4,belement3]]*)
(*);*)
(**)
(**)
(*createH2Tensor[basis_]:=( *)
(**)
(*Return[ParallelTable[alpha*createH2SubElement[basis[[i]],basis[[j]],basis[[k]],basis[[l]]],{i,1,numbas},{j,1,numbas},{k,1,numbas},{l,1,numbas}]]*)
(**)
(*);*)
(**)
(**)
(*createH2Matrix[densitymat_,h2tensor_]:=( *)
(**)
(*Return[Sum[densitymat[[j,i]]*h2tensor[[All,i,j,All]],{i,1,numbas},{j,1,numbas}]]*)
(*);*)
(**)
(**)
(*createFockMatrix[basis_,coeff_,h2tensor_]:=( *)
(**)
(*Return[createH1Matrix[basis]+createH2Matrix[createDensityMatrix[coeff],h2tensor]]*)
(*);*)
(**)
(*iterateFockMatrix[h1matrix_,h2tensor_,previousfm_]:=( *)
(*Module[{eigenvec={},newcoeff=0},*)
(*eigenvec=Reverse[Eigenvectors[previousfm]];*)
(*newcoeff=eigenvec[[1;;numpar]];*)
(**)
(*Return[h1matrix+createH2Matrix[createDensityMatrix[newcoeff],h2tensor]];*)
(*]*)
(*);*)
(**)
(*create1PWaveFunction[particleindex_,coeff_,basis_]:=( *)
(*Return[Table[{coeff[[particleindex,i]]basis[[i,1]],basis[[i,2]]},{i,1,numbas}]];*)
(**)
(*);*)
(**)
(*createSlaterDeterminant[list1PWaveFunction_]:=( *)
(*dummywf=Table[Subscript[\[Psi], i],{i,1,numpar}];*)
(*Module[{perm},*)
(**)
(*perm=Permutations[dummywf];*)
(*perm=Table[Prepend[perm[[i]],Signature[perm[[i]]]],{i,1,Length[perm]}];*)
(*(*Return[perm];*)*)
(*Return[perm/.Table[Subscript[\[Psi], i]->list1PWaveFunction[[i]],{i,1,numpar}]];*)
(**)
(*];*)
(*);*)
(**)
(**)
(*simple1PInnerProduct[p1wf_,p2wf_]:=( *)
(**)
(*Return[Sum[simpleInnerProduct[p1wf[[i]],p2wf[[j]]],{i,1,numbas},{j,1,numbas}]]*)
(**)
(*);*)
(**)
(*simplePermInnerProduct[npwf1_,npwf2_]:=( *)
(**)
(*signp1=npwf1[[1]];*)
(*signp2=npwf2[[1]];*)
(*Delete[npwf1,1];*)
(*Delete[npwf2,2];*)
(*Return[signp1*signp2*Product[simple1PInnerProduct[npwf1[[i]],npwf2[[i]]],{i,1,numpar}]];*)
(**)
(*);*)
(**)
(*coordinatePermRepresentation[perm_]:=( *)
(*Module[{unmultipliedwf,multipliedwf},*)
(**)
(*sign=perm[[1]];*)
(*unmultipliedwf=Table[perm[[1+i]]/.{x->Subscript[x, i],up->Subscript[up, i],down->Subscript[down, i]},{i,1,numpar}];*)
(*unmultipliedwf=Table[Times@@unmultipliedwf[[i,j]],{i,1,numpar},{j,1,numbas}];*)
(*unmultipliedwf=Table[Total[unmultipliedwf[[i]]],{i,1,numpar}];*)
(*multipliedwf=Times@@unmultipliedwf;*)
(**)
(*Return[sign*multipliedwf];*)
(*];*)
(*);*)
(**)
(*coordinateSDRepresentation[sd_]:=( *)
(**)
(*Return[Sum[coordinatePermRepresentation[sd[[i]]],{i,1,Length[sd]}]/Sqrt[Length[sd]]];*)
(*);*)
(**)
(*getSpatialPD[coordpd_]:=( *)
(*(*only works for 2 particle wf*)*)
(*placeholder=coordpd;*)
(*blah1=placeholder/.{Subscript[up, 1]->1,Subscript[down, 1]->0,Subscript[up, 2]->1,Subscript[down, 2]->0};*)
(*blah2=placeholder/.{Subscript[up, 1]->1,Subscript[down, 1]->0,Subscript[up, 2]->0,Subscript[down, 2]->1};*)
(*blah3=placeholder/.{Subscript[up, 1]->0,Subscript[down, 1]->1,Subscript[up, 2]->1,Subscript[down, 2]->0};*)
(*blah4=placeholder/.{Subscript[up, 1]->0,Subscript[down, 1]->1,Subscript[up, 2]->0,Subscript[down, 2]->1};*)
(**)
(*Return[blah1+blah2+blah3+blah4];*)
(**)
(**)
(*);*)
(**)
(**)
(**)
(*startInitialization[6,2, -1000000];*)
(*basis=createSinBasis[];*)
(*initcoeff=createRandomIC[];*)
(*h1matrix = createH1Matrix[basis];*)
(*h2tensor= createH2Tensor[basis];*)
(*oldfock=createFockMatrix[basis,initcoeff,h2tensor];*)
(**)
(**)
(*For[i = 0, i < 10,i++, oldfock = iterateFockMatrix[h1matrix, h2tensor,oldfock]];*)
(**)
(**)
(*eigenvec=Reverse[Eigenvectors[oldfock]];*)
(*newcoeff=eigenvec[[1;;numpar]];*)
(**)
(**)
(**)
(**)
(*par1=create1PWaveFunction[1,newcoeff,basis];*)
(*par2=create1PWaveFunction[2,newcoeff,basis];*)
(**)
(*sd=createSlaterDeterminant[{par1,par2}];*)
(*coordsd=coordinateSDRepresentation[sd]//Chop;*)
(*pd=Abs[Expand[coordsd]]^2;*)
(**)
(*pdpos=getSpatialPD[pd]//FullSimplify*)
(**)
(*Plot3D[pdpos,{Subscript[x, 1],0,1},{Subscript[x, 2],0,1}]*)
(**)
(**)
(*End[]*)
(**)
(*EndPackage[]*)
(**)
(**)
(**)
(**)
(**)



